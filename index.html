<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Heat Pump 3D Viewer (STL/OBJ)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#202020; }
    canvas { display:block; }
    #msg {
      position:fixed; left:10px; top:10px; right:10px;
      color:#fff; background:rgba(0,0,0,0.55);
      font:12px/1.4 ui-monospace, Menlo, Consolas, monospace;
      padding:10px; border-radius:8px; z-index:9999;
      white-space:pre-wrap; display:none;
    }
  </style>
</head>
<body>
<div id="msg"></div>

<!-- ✅ 안정 버전 (OrbitControls / OBJLoader 전역 방식 호환) -->
<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>

<script>
const msg = document.getElementById("msg");
function show(text){ msg.style.display="block"; msg.textContent = text; }
function append(text){ msg.style.display="block"; msg.textContent += "\n" + text; }

window.addEventListener("error", (e)=> show("❌ JS 오류:\n" + (e.message || e)) );
window.addEventListener("unhandledrejection", (e)=> show("❌ Promise 오류:\n" + (e.reason?.message || e.reason || e)) );

// ✅ OBJ 기본으로 열기
// const DEFAULT_MODEL_URL = "https://raw.githubusercontent.com/sjnaraeon/Doowon/main/sample.obj";
// STL로 바꾸려면 아래처럼:
const DEFAULT_MODEL_URL = "https://raw.githubusercontent.com/sjnaraeon/Doowon/main/sample.stl";

function getParam(name) {
  const url = new URL(window.location.href);
  return url.searchParams.get(name);
}
const modelUrl = getParam("model") || DEFAULT_MODEL_URL;

append("modelUrl = " + modelUrl);
append("THREE loaded = " + (typeof THREE !== "undefined"));
append("OrbitControls = " + (typeof THREE.OrbitControls));
append("OBJLoader = " + (typeof THREE.OBJLoader));
append("STLLoader = " + (typeof THREE.STLLoader));

if (typeof THREE === "undefined") throw new Error("THREE not loaded");
if (typeof THREE.OBJLoader === "undefined") append("⚠️ OBJLoader가 로드되지 않았습니다(차단/URL 오류).");

// Scene / Camera / Renderer
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 5000);
camera.position.set(200, 200, 200);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// Light
scene.add(new THREE.AmbientLight(0xffffff, 0.75));
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(1, 1, 1);
scene.add(dir);

// Controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.target.set(0,0,0);
controls.update();

let currentObject = null;
function replaceObject(obj){
  if (currentObject) scene.remove(currentObject);
  currentObject = obj;
  scene.add(obj);
}

// 중심/스케일 맞추기
function centerAndScaleObject(obj){
  const box = new THREE.Box3().setFromObject(obj);
  const size = new THREE.Vector3();
  box.getSize(size);

  // 모델이 비어있으면 여기서 size가 0이 될 수 있음
  const maxDim = Math.max(size.x, size.y, size.z);
  append("bbox size = " + size.x.toFixed(3) + ", " + size.y.toFixed(3) + ", " + size.z.toFixed(3));

  const center = new THREE.Vector3();
  box.getCenter(center);
  obj.position.sub(center);

  if (maxDim > 0) {
    const s = 150 / maxDim;
    obj.scale.multiplyScalar(s);
  } else {
    append("⚠️ 모델 bounding box가 0 입니다(면/선/점 데이터가 없을 수 있음).");
  }

  controls.target.set(0,0,0);
  controls.update();
}

// OBJ가 “선/점”인 경우도 보이게 재질 강제 적용
function forceVisibleMaterials(obj){
  let meshCount = 0, lineCount = 0, pointCount = 0;

  obj.traverse((child)=>{
    if (child.isMesh) {
      meshCount++;
      child.material = new THREE.MeshStandardMaterial({
        color: 0x00aaff,
        metalness: 0.1,
        roughness: 0.6,
        side: THREE.DoubleSide
      });
      if (child.geometry) child.geometry.computeVertexNormals();
    } else if (child.isLine || child.isLineSegments) {
      lineCount++;
      child.material = new THREE.LineBasicMaterial({ color: 0x00ff99 });
    } else if (child.isPoints) {
      pointCount++;
      child.material = new THREE.PointsMaterial({ color: 0xffff00, size: 2 });
    }
  });

  append(`visible types: mesh=${meshCount}, line=${lineCount}, points=${pointCount}`);
}

// 확장자 판단
function getExt(url){
  const clean = url.split("?")[0].split("#")[0];
  return clean.substring(clean.lastIndexOf(".")+1).toLowerCase();
}

async function loadModel(url){
  const ext = getExt(url);

  // 네트워크 확인(OBJ/ STL 다운로드가 가능한지)
  try {
    const res = await fetch(url, { cache:"no-store" });
    append(`fetch ${ext}: ${res.status} ${res.statusText}`);
    if (!res.ok) append("⚠️ fetch가 실패했습니다(404/차단).");
  } catch(e) {
    append("❌ fetch 예외: " + (e.message || e));
  }

  if (ext === "stl") {
    const loader = new THREE.STLLoader();
    loader.load(url, (geometry)=>{
      geometry.computeBoundingBox();
      geometry.computeVertexNormals();

      const mat = new THREE.MeshStandardMaterial({
        color: 0x00aaff, metalness:0.1, roughness:0.6, side:THREE.DoubleSide
      });

      const mesh = new THREE.Mesh(geometry, mat);

      const box = geometry.boundingBox;
      const center = new THREE.Vector3();
      box.getCenter(center);
      mesh.position.sub(center);

      const size = new THREE.Vector3();
      box.getSize(size);
      const s = 150 / Math.max(size.x, size.y, size.z);
      mesh.scale.setScalar(s);

      replaceObject(mesh);
      append("✅ STL loaded");
    }, undefined, (err)=>{
      append("❌ STLLoader error: " + (err?.message || err));
    });

  } else if (ext === "obj") {
    if (typeof THREE.OBJLoader === "undefined") {
      show("❌ OBJLoader가 로드되지 않았습니다.\n(OBJLoader.js URL 차단/오류 가능)\n\n조치: 이 HTML의 OBJLoader 스크립트 URL을 확인하세요.");
      return;
    }

    const loader = new THREE.OBJLoader();
    loader.load(url, (obj)=>{
      forceVisibleMaterials(obj);
      centerAndScaleObject(obj);
      replaceObject(obj);
      append("✅ OBJ loaded");
    }, undefined, (err)=>{
      append("❌ OBJLoader error: " + (err?.message || err));
    });

  } else {
    show("❌ 지원하지 않는 확장자: " + ext);
  }
}

addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

loadModel(modelUrl);
</script>
</body>
</html>
